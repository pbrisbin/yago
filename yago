#!/bin/bash
#
# Yet Another GetOpt. pbrisbin 2011
#
###

errorout() { # {{{
  local errno=$1; shift
  echo "error: $*" >&2; exit $errno
} # }}}

invalid_option()   { errorout 2 "invalid option $1"      ; }
missing_option()   { errorout 3 "option $1 is required" ; }
duplicate_option() { errorout 4 "duplicate option $1 "   ; }
missing_argument() { errorout 5 "missing argument for $1"; }
extra_argument()   { errorout 6 "extra argument for $1"  ; }

set_values() { # {{{
  local parse_info arg n

  local long_opt short_opt opt_message default nargs argument \
    variable required

  sopts_list=()
  lopts_list=()

  for arg in "${opts[@]}"; do
    [[ -z "$arg" ]] && continue

    IFS=',' read -a parse_info <<< "$arg"
    n="${#parse_info[@]}"

    [[ $n -lt 3 || $n -gt 7 ]] && errorout 1 'invalid number of tokens in option definiton'

    # todo: trim whitespace more efficiently
    long_opt=$(   echo ${parse_info[0]})
    short_opt=$(  echo ${parse_info[1]})
    opt_message=$(echo ${parse_info[2]})

    [[ $n -ge 4 ]] && default=$( echo ${parse_info[3]}) || default=false
    [[ $n -ge 5 ]] && nargs=$(   echo ${parse_info[4]}) || nargs=0
    [[ $n -ge 6 ]] && argument=$(echo ${parse_info[5]}) || argument='<ARG>'
    [[ $n -ge 7 ]] && variable=$(echo ${parse_info[6]}) || variable="$long_opt"

    [[ -n "$default" && "$default" != 'REQUIRED' ]] && required=false || required=true

    [[ "$nargs" != 'N' && -n "${nargs//[0-9]/}" ]] && errorout 1 "invalid number of arguments, token was \`$nargs'"

    # add to a list of keys
    sopts_list[$short_opt]="$long_opt"
    lopts_list[$long_opt]="$short_opt"

    # create an "extension table" of parameters, last field is "seen"
    eval "$long_opt=( \"$short_opt\" \"$opt_message\" \"$default\" \"$nargs\" \"$argument\" \"$variable\" $required false)"

    # clear variables for next option
    unset long_opt short_opt opt_message default nargs argument variable \
      required
  done
} # }}}

help_message() { # {{{
  local long_opt short_opt opt_message nargs argument required \
    lb rb sopt usage options_list

  # TODO it appears associative arrays are stored in the reverse order
  # they're declared. this may not be true, but i use it to print the
  # help in the order it was defined
  for long_opt in ${!lopts_list[@]}; do
    eval "short_opt=\${$long_opt[0]}"
    eval "opt_message=\${$long_opt[1]}"
    eval "nargs=\${$long_opt[3]}"
    eval "argument=\${$long_opt[4]}"
    eval "required=\${$long_opt[6]}"

    $required || { lb='[ '; rb=' ]'; }

    case "$nargs" in # compare as string
      '0') sopt="$lb-$short_opt$rb"              ; argument=''              ;;
      '1') sopt="$lb-$short_opt $argument$rb"                               ;;
      *)   sopt="$lb-$short_opt $argument ...$rb"; argument="$argument ..." ;;
    esac

    usage="$sopt $usage"
    options_list=( "$(printf "    %-25.25s %s" "-$short_opt, --$long_opt$argument" "$opt_message")" "${options_list[@]}" )

    unset short_opt opt_message nargs argument required lb rb sopt lopt
  done

  echo "usage: $progname $usage" >&2
  printf "%s\n" "${options_list[@]}" >&2
  echo "exit 1"

  exit 0
} # }}}

setup_short_opt() { # {{{
  sopt="${1/-/}"
  lopt="${sopts_list[$sopt]}"

  [[ -z "$lopt" ]]    && invalid_option "-$sopt"
  eval "\${$lopt[7]}" && duplicate_option "-$sopt"
} # }}}

setup_long_opt() { # {{{
  lopt="${1/--/}"
  sopt="${lopts_list[$lopt]}"

  [[ -z "$sopt" ]]    && invalid_option "--$lopt"
  eval "\${$lopt[7]}" && duplicate_option "--$lopt"
} # }}}

consume_args() { # {{{
  local nexpd="$1" nseen=0; shift

  while [[ -n "$1" && ! "$1" =~ -.* ]]; do
    nseen=$((nseen+1))
    [[ "$nexpd" != 'N' && $nseen -gt $nexpd ]] && extra_argument "--$lopt"

    optargs+=( "$1" ); shift
  done

  [[ "$nexpd" != 'N' && $nseen -ne $nexpd ]] && missing_argument "--$lopt"
  [[ "$nexpd" == 'N' && $nseen -eq 0      ]] && missing_argument "--$lopt"

  return $nseen
} # }}}

set_unseen_args() { # {{{
  local lopt required seen default nargs

  for lopt in "${!lopts_list[@]}"; do
    eval "default=\${$lopt[2]}"
    eval "nargs=\${$lopt[3]}"
    eval "required=\${$lopt[6]}"
    eval "seen=\${$lopt[7]}"

    $seen     && continue
    $required && missing_option "--$lopt"

    case "$nargs" in
      0) output+=( "$lopt=$default" )     ;;
      *) output+=( "$lopt=( $default )" ) ;;
    esac
  done
} # }}}

declare -a opts
declare -a optargs
declare -a output

declare -A sopts_list
declare -A lopts_list

# store the program name to be used by the help message as well as the
# string we need to parse into the options structures.
progname="$1"; shift
ifs=$IFS; IFS=$'\n' opts=( $1 ); IFS=$ifs; shift;

# set two key value arrays which map valid long to short options and
# valid short to long options (to make lookups either way convenient) as
# well as an array named for each long option which holds all of the
# information about it: short opt, message, default, required, etc.
set_values

while [[ -n "$1" ]]; do
  case "$1" in
    -h|--help) help_message         ;;
    --)        shift; break         ;;
    --*)       setup_long_opt  "$1" ;;
    -*)        setup_short_opt "$1" ;;
    *)         break ;; # unconsumed arg
  esac
  shift

  eval "nargs=\${$lopt[3]}"

  if [[ "$nargs" != 'N' && $nargs -eq 0 ]]; then
    output+=( "$lopt=true" )
  else
    # fill optargs and return the number of arguments which were
    # consumed by the process. error on too few or too many
    consume_args "$nargs" "$@"
    shift $? # move passed

    output+=( "$lopt=( $(printf '"%s" ' "${optargs[@]}"))" )
  fi

  declare $lopt[7]=true

  unset nargs ret lopt sopt
  optargs=()
done

# any leftover args get placed in an args array
[[ "$#" -ne 0 ]] && output+=(  "args=( $(printf '"%s" ' "$@"))" )

# roll through any options we haven't seen yet. if they're required
# throw an error, otherwise set them to the default value and add to the
# output array
set_unseen_args

printf "%s\n" "${output[@]}"
exit 0
